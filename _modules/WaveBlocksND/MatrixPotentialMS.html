<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>WaveBlocksND.MatrixPotentialMS &mdash; WaveBlocksND devel documentation</title>
    
    <link rel="stylesheet" href="../../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     'devel',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="top" title="WaveBlocksND devel documentation" href="../../index.html" />
    <link rel="up" title="Module code" href="../index.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">WaveBlocksND devel documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for WaveBlocksND.MatrixPotentialMS</h1><div class="highlight"><pre>
<span></span><span class="sd">r&quot;&quot;&quot;The WaveBlocks Project</span>

<span class="sd">This file contains code for the representation of potentials :math:`V(x)`</span>
<span class="sd">that contain three or more energy levels :math:`\lambda_i`. (In principle</span>
<span class="sd">the code works also with 1 or 2 levels, but it is not used that way.)</span>
<span class="sd">The number of space dimensions can be arbitrary, :math:`x \in \mathbb{R}^D`.</span>

<span class="sd">@author: R. Bourquin</span>
<span class="sd">@copyright: Copyright (C) 2010, 2011, 2012, 2014 R. Bourquin</span>
<span class="sd">@license: Modified BSD License</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">sympy</span>
<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="k">import</span> <span class="n">linalg</span>

<span class="kn">from</span> <span class="nn">WaveBlocksND.MatrixPotential</span> <span class="k">import</span> <span class="n">MatrixPotential</span>
<span class="kn">from</span> <span class="nn">WaveBlocksND.AbstractGrid</span> <span class="k">import</span> <span class="n">AbstractGrid</span>
<span class="kn">from</span> <span class="nn">WaveBlocksND.GridWrapper</span> <span class="k">import</span> <span class="n">GridWrapper</span>
<span class="kn">from</span> <span class="nn">WaveBlocksND</span> <span class="k">import</span> <span class="n">GlobalDefaults</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;MatrixPotentialMS&quot;</span><span class="p">]</span>


<div class="viewcode-block" id="MatrixPotentialMS"><a class="viewcode-back" href="../../waveblocks_classes/MatrixPotentialMS.html#WaveBlocksND.MatrixPotentialMS">[docs]</a><span class="k">class</span> <span class="nc">MatrixPotentialMS</span><span class="p">(</span><span class="n">MatrixPotential</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;This class represents a matrix potential :math:`V(x)`. The potential is</span>
<span class="sd">    given as an analytic :math:`N \times N` matrix expression. All methods use</span>
<span class="sd">    pure numerical techniques because symbolical calculations are unfeasible</span>
<span class="sd">    for 3 or more energy levels.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expression</span><span class="p">,</span> <span class="n">variables</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;Create a new :py:class:`MatrixPotentialMS` instance for a given</span>
<span class="sd">        potential matrix :math:`V(x)`.</span>

<span class="sd">        :param expression: The mathematical expression representing the potential.</span>
<span class="sd">        :type expressiom: A `Sympy` matrix type.</span>
<span class="sd">        :param variables: The variables corresponding to the space dimensions.</span>
<span class="sd">        :type variables: A list of `Sympy` symbols.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># The variables that represents position space. The order matters!</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span> <span class="o">=</span> <span class="n">variables</span>

        <span class="c1"># The dimension of position space.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dimension</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">variables</span><span class="p">)</span>

        <span class="c1"># Do we want to make eigenvectors continuous</span>
        <span class="c1"># TODO: This is an experimental feature!</span>
        <span class="k">if</span> <span class="s2">&quot;continuous_eigenvectors&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_continuous_eigenvectors</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;continuous_eigenvectors&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_continuous_eigenvectors</span> <span class="o">=</span> <span class="n">GlobalDefaults</span><span class="o">.</span><span class="n">__dict__</span><span class="p">[</span><span class="s2">&quot;continuous_eigenvectors&quot;</span><span class="p">]</span>

        <span class="c1"># This number of energy levels.</span>
        <span class="k">assert</span> <span class="n">expression</span><span class="o">.</span><span class="n">is_square</span>
        <span class="c1"># We handle the general NxN case here</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_number_components</span> <span class="o">=</span> <span class="n">expression</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># The the potential, symbolic expressions and evaluatable functions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_potential_s</span> <span class="o">=</span> <span class="n">expression</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_potential_n</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">sympy</span><span class="o">.</span><span class="n">lambdify</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="s2">&quot;numpy&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_potential_s</span><span class="p">)</span>

        <span class="c1"># The Jacobian and Hessian matrices of all entries of V</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_JV_s</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_JV_n</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_HV_s</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_HV_n</span> <span class="o">=</span> <span class="kc">None</span>


    <span class="k">def</span> <span class="nf">_grid_wrap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">agrid</span><span class="p">):</span>
        <span class="c1"># TODO: Consider additional input types for &quot;nodes&quot;:</span>
        <span class="c1">#       list of numpy ndarrays, list of single python scalars</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">agrid</span><span class="p">,</span> <span class="n">AbstractGrid</span><span class="p">):</span>
            <span class="n">agrid</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">agrid</span><span class="p">)</span>
            <span class="n">agrid</span> <span class="o">=</span> <span class="n">agrid</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dimension</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">agrid</span> <span class="o">=</span> <span class="n">GridWrapper</span><span class="p">(</span><span class="n">agrid</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">agrid</span>


<div class="viewcode-block" id="MatrixPotentialMS.evaluate_at"><a class="viewcode-back" href="../../waveblocks_classes/MatrixPotentialMS.html#WaveBlocksND.MatrixPotentialMS.evaluate_at">[docs]</a>    <span class="k">def</span> <span class="nf">evaluate_at</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">entry</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">as_matrix</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;Evaluate the potential :math:`V(x)` elementwise on a grid :math:`\Gamma`.</span>

<span class="sd">        :param grid: The grid containing the nodes :math:`\gamma_i` we want</span>
<span class="sd">                     to evaluate the potential at.</span>
<span class="sd">        :type grid: A :py:class:`Grid` instance. (Numpy arrays are not directly supported yet.)</span>
<span class="sd">        :param entry: The indices :math:`(i,j)` of the component :math:`V_{i,j}(x)`</span>
<span class="sd">                      we want to evaluate or ``None`` to evaluate all entries.</span>
<span class="sd">        :type entry: A python tuple of two integers.</span>
<span class="sd">        :param as_matrix: Dummy parameter which has no effect here.</span>
<span class="sd">        :return: A list containing :math:`N^2` numpy ndarrays of shape :math:`(1, |\Gamma|)`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grid_wrap</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>

        <span class="c1"># Determine which entries to evaluate</span>
        <span class="k">if</span> <span class="n">entry</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span> <span class="o">=</span> <span class="n">entry</span>
            <span class="n">entries</span> <span class="o">=</span> <span class="p">[</span><span class="n">row</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_number_components</span> <span class="o">+</span> <span class="n">col</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">N</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_number_components</span>
            <span class="n">entries</span> <span class="o">=</span> <span class="p">[</span><span class="n">row</span> <span class="o">*</span> <span class="n">N</span> <span class="o">+</span> <span class="n">col</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)]</span>

        <span class="c1"># Evaluate all entries specified</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">nodes</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">get_nodes</span><span class="p">(</span><span class="n">split</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">entries</span><span class="p">:</span>
            <span class="c1"># Evaluate the potential at the given nodes</span>
            <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_potential_n</span><span class="p">[</span><span class="n">index</span><span class="p">](</span><span class="o">*</span><span class="n">nodes</span><span class="p">)</span>

            <span class="c1"># Test for potential being constant</span>
            <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">values</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="p">,):</span>
                <span class="n">values</span> <span class="o">=</span> <span class="n">values</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">get_number_nodes</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">)</span>

            <span class="c1"># Put the result in correct shape (1, #gridnodes)</span>
            <span class="n">N</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">get_number_nodes</span><span class="p">(</span><span class="n">overall</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">)))</span>

        <span class="c1"># TODO: Consider unpacking single ndarray iff entry != None</span>
        <span class="k">if</span> <span class="n">entry</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">result</span><span class="p">)</span></div>


<div class="viewcode-block" id="MatrixPotentialMS.calculate_eigenvalues"><a class="viewcode-back" href="../../waveblocks_classes/MatrixPotentialMS.html#WaveBlocksND.MatrixPotentialMS.calculate_eigenvalues">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_eigenvalues</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;Calculate all the eigenvalues :math:`\lambda_i(x)` of the potential :math:`V(x)`.</span>
<span class="sd">        We can not do this by symbolic calculations, hence the function has an empty</span>
<span class="sd">        implementation. We compute the eigenvalues by numerical techniques in the corresponding</span>
<span class="sd">        `evaluate_eigenvalues_at` function.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>


<div class="viewcode-block" id="MatrixPotentialMS.evaluate_eigenvalues_at"><a class="viewcode-back" href="../../waveblocks_classes/MatrixPotentialMS.html#WaveBlocksND.MatrixPotentialMS.evaluate_eigenvalues_at">[docs]</a>    <span class="k">def</span> <span class="nf">evaluate_eigenvalues_at</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">entry</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">as_matrix</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="nb">sorted</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;Evaluate the eigenvalues :math:`\lambda_i(x)` elementwise on a grid :math:`\Gamma`.</span>

<span class="sd">        :param grid: The grid containing the nodes :math:`\gamma_i` we want</span>
<span class="sd">                     to evaluate the eigenvalues at.</span>
<span class="sd">        :type grid: A :py:class:`Grid` instance. (Numpy arrays are not directly supported yet.)</span>
<span class="sd">        :param entry: The indices :math:`(i,j)` of the component :math:`\Lambda_{i,j}(x)`</span>
<span class="sd">                      we want to evaluate or ``None`` to evaluate all entries. If :math:`j = i`</span>
<span class="sd">                      then we evaluate the eigenvalue :math:`\lambda_i(x)`.</span>
<span class="sd">        :type entry: A python tuple of two integers.</span>
<span class="sd">        :param as_matrix: Whether to include the off-diagonal zero entries of</span>
<span class="sd">                          :math:`\Lambda_{i,j}(x)` in the return value.</span>
<span class="sd">        :return: A list containing the numpy ndarrays, all of shape :math:`(1, |\Gamma|)`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grid_wrap</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>

        <span class="n">N</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_number_components</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">get_number_nodes</span><span class="p">(</span><span class="n">overall</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Early return shortcut for off-diagonal entries</span>
        <span class="k">if</span> <span class="n">entry</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span> <span class="o">=</span> <span class="n">entry</span>
            <span class="k">if</span> <span class="n">row</span> <span class="o">!=</span> <span class="n">col</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">)</span>

        <span class="c1"># Memory for storing temporary values</span>
        <span class="n">tmppot</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">N</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">)</span>
        <span class="n">tmpew</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">N</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">)</span>

        <span class="c1"># Evaluate potential</span>
        <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_at</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>

        <span class="c1"># Fill in values</span>
        <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
                <span class="n">tmppot</span><span class="p">[:,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="n">N</span> <span class="o">*</span> <span class="n">row</span> <span class="o">+</span> <span class="n">col</span><span class="p">]</span>

        <span class="c1"># Calculate eigenvalues assuming hermitian matrix (eigvalsh for stability!)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">ew</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">eigvalsh</span><span class="p">(</span><span class="n">tmppot</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:])</span>
            <span class="k">if</span> <span class="nb">sorted</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="c1"># Sorting the eigenvalues, biggest first.</span>
                <span class="c1"># TODO: Sort will fail iff energy level cross!</span>
                <span class="n">ew</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
                <span class="n">tmpew</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">ew</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Do not sort</span>
                <span class="n">tmpew</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">ew</span><span class="p">[:]</span>

        <span class="c1"># Split the data into different eigenvalues</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="p">[</span><span class="n">tmpew</span><span class="p">[:,</span> <span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span> <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)]</span>

        <span class="k">if</span> <span class="n">entry</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span> <span class="o">=</span> <span class="n">entry</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">[</span><span class="n">row</span><span class="p">]</span>
            <span class="c1"># Offdiagonal case handled on top</span>
        <span class="k">elif</span> <span class="n">as_matrix</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">row</span> <span class="o">==</span> <span class="n">col</span><span class="p">:</span>
                        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tmp</span><span class="p">[</span><span class="n">row</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">tmp</span><span class="p">[</span><span class="n">row</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="MatrixPotentialMS.calculate_eigenvectors"><a class="viewcode-back" href="../../waveblocks_classes/MatrixPotentialMS.html#WaveBlocksND.MatrixPotentialMS.calculate_eigenvectors">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_eigenvectors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;Calculate all the eigenvectors :math:`\nu_i(x)` of the potential :math:`V(x)`.</span>
<span class="sd">        We can not do this by symbolic calculations, hence the function has an empty</span>
<span class="sd">        implementation. We compute the eigenvectors by numerical techniques in the corresponding</span>
<span class="sd">        `evaluate_eigenvectors_at` function.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>


<div class="viewcode-block" id="MatrixPotentialMS.evaluate_eigenvectors_at"><a class="viewcode-back" href="../../waveblocks_classes/MatrixPotentialMS.html#WaveBlocksND.MatrixPotentialMS.evaluate_eigenvectors_at">[docs]</a>    <span class="k">def</span> <span class="nf">evaluate_eigenvectors_at</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="nb">sorted</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;Evaluate the eigenvectors :math:`\nu_i(x)` elementwise on a grid :math:`\Gamma`.</span>

<span class="sd">        :param grid: The grid containing the nodes :math:`\gamma_i` we want</span>
<span class="sd">                     to evaluate the eigenvectors at.</span>
<span class="sd">        :type grid: A :py:class:`Grid` instance. (Numpy arrays are not directly supported yet.)</span>
<span class="sd">        :return: A list containing the :math:`N` numpy ndarrays, all of shape :math:`(D, |\Gamma|)`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grid_wrap</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>

        <span class="n">N</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_number_components</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">get_number_nodes</span><span class="p">(</span><span class="n">overall</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Memory for storing temporary values</span>
        <span class="n">tmppot</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">N</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">)</span>
        <span class="n">tmpev</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">N</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">)</span>

        <span class="c1"># Evaluate potential</span>
        <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_at</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>

        <span class="c1"># Fill in values</span>
        <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
                <span class="n">tmppot</span><span class="p">[:,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="n">N</span> <span class="o">*</span> <span class="n">row</span> <span class="o">+</span> <span class="n">col</span><span class="p">]</span>

        <span class="c1"># Calculate eigenvectors assuming hermitian matrix (eigh for stability!)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">ew</span><span class="p">,</span> <span class="n">ev</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="n">tmppot</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:])</span>
            <span class="k">if</span> <span class="nb">sorted</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="c1"># Sorting the eigenvectors in the same order as the eigenvalues.</span>
                <span class="n">ind</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">ew</span><span class="p">)</span>
                <span class="n">ind</span> <span class="o">=</span> <span class="n">ind</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">evs</span> <span class="o">=</span> <span class="n">ev</span><span class="p">[:,</span> <span class="n">ind</span><span class="p">]</span>
                <span class="n">tmpev</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">evs</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># No sorting</span>
                <span class="n">tmpev</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">ev</span>

        <span class="c1"># A trick due to G. Hagedorn to get continuous eigenvectors</span>
        <span class="c1"># TODO: Not sure if it works in higher dimensions too! (Probably it does not)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_continuous_eigenvectors</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">ev</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">tmpev</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:,</span> <span class="n">ev</span><span class="p">],</span> <span class="n">tmpev</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="n">ev</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">tmpev</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:,</span> <span class="n">ev</span><span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>

        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">tmpev</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">index</span><span class="p">])</span> <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">))</span></div>


<div class="viewcode-block" id="MatrixPotentialMS.calculate_exponential"><a class="viewcode-back" href="../../waveblocks_classes/MatrixPotentialMS.html#WaveBlocksND.MatrixPotentialMS.calculate_exponential">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_exponential</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">factor</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;Calculate the matrix exponential :math:`\exp(\alpha V)`. In the case</span>
<span class="sd">        of this class the matrix is of size :math:`N \times N` thus the exponential</span>
<span class="sd">        can not be calculated analytically for a general matrix. We use numerical</span>
<span class="sd">        approximations to determine the matrix exponential. We just store</span>
<span class="sd">        the prefactor :math:`\alpha` for use during numerical evaluation.</span>

<span class="sd">        :param factor: The prefactor :math:`\alpha` in the exponential.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Store the factor for later numerical computations.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_factor</span> <span class="o">=</span> <span class="n">factor</span></div>


<div class="viewcode-block" id="MatrixPotentialMS.evaluate_exponential_at"><a class="viewcode-back" href="../../waveblocks_classes/MatrixPotentialMS.html#WaveBlocksND.MatrixPotentialMS.evaluate_exponential_at">[docs]</a>    <span class="k">def</span> <span class="nf">evaluate_exponential_at</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;Evaluate the exponential of the potential matrix :math:`V(x)` on a grid :math:`\Gamma`.</span>

<span class="sd">        :param grid: The grid containing the nodes :math:`\gamma_i` we want</span>
<span class="sd">                     to evaluate the exponential at.</span>
<span class="sd">        :type grid: A :py:class:`Grid` instance. (Numpy arrays are not directly supported yet.)</span>
<span class="sd">        :return: The numerical approximation of the matrix exponential at the given grid nodes.</span>
<span class="sd">                 A list contains the exponentials for all entries :math:`(i,j)`, each having</span>
<span class="sd">                 a shape of :math:`(1, |\Gamma|)`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grid_wrap</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>

        <span class="n">N</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_number_components</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">get_number_nodes</span><span class="p">(</span><span class="n">overall</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Memory for storing temporary values</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">N</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">)</span>

        <span class="c1"># Evaluate potential</span>
        <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_at</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>

        <span class="c1"># Fill in values</span>
        <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
                <span class="n">tmp</span><span class="p">[:,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_factor</span> <span class="o">*</span> <span class="n">values</span><span class="p">[</span><span class="n">N</span> <span class="o">*</span> <span class="n">row</span> <span class="o">+</span> <span class="n">col</span><span class="p">]</span>

        <span class="c1"># Calculate exponential</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">tmp</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">expm</span><span class="p">(</span><span class="n">tmp</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:])</span>

        <span class="c1"># Split the data into different components</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">tmp</span><span class="p">[:,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">))</span></div>


    <span class="k">def</span> <span class="nf">_calculate_jacobian_of_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">entry</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;Compute the Jacobian of the matrix elements :math:`V_{i,j}`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_JV_s</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_JV_s</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_JV_n</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">variable</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_JV_s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">sympy</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">variable</span><span class="p">)</span> <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_potential_s</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_JV_s</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_JV_n</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">sympy</span><span class="o">.</span><span class="n">lambdify</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="s2">&quot;numpy&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">v</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">_calculate_hessian_of_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">entry</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;Compute the Hessian of the matrix elements :math:`V_{i,j}`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_HV_s</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_HV_s</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_HV_n</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">variable1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">variable2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_HV_s</span><span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">sympy</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">sympy</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">variable1</span><span class="p">),</span> <span class="n">variable2</span><span class="p">)</span> <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_potential_s</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_HV_s</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_HV_n</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">sympy</span><span class="o">.</span><span class="n">lambdify</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="s2">&quot;numpy&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">val</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">_evaluate_jacobian_of_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variable</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">entry</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># Note: We assume grid is already of supertype Grid</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">get_number_nodes</span><span class="p">(</span><span class="n">overall</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">N</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_number_components</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">get_nodes</span><span class="p">(</span><span class="n">split</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">dAdxk</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">N</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
                <span class="n">dAdxk</span><span class="p">[:,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_JV_n</span><span class="p">[</span><span class="n">variable</span><span class="p">][</span><span class="n">N</span> <span class="o">*</span> <span class="n">row</span> <span class="o">+</span> <span class="n">col</span><span class="p">](</span><span class="o">*</span><span class="n">nodes</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">dAdxk</span>


    <span class="k">def</span> <span class="nf">_evaluate_hessian_of_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variables</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">entry</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># Note: We assume grid is already of supertype Grid</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">get_number_nodes</span><span class="p">(</span><span class="n">overall</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">N</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_number_components</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">get_nodes</span><span class="p">(</span><span class="n">split</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">dAdxidxj</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">N</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
                <span class="n">dAdxidxj</span><span class="p">[:,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_HV_n</span><span class="p">[</span><span class="n">variables</span><span class="p">][</span><span class="n">N</span> <span class="o">*</span> <span class="n">row</span> <span class="o">+</span> <span class="n">col</span><span class="p">](</span><span class="o">*</span><span class="n">nodes</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">dAdxidxj</span>


<div class="viewcode-block" id="MatrixPotentialMS.calculate_jacobian"><a class="viewcode-back" href="../../waveblocks_classes/MatrixPotentialMS.html#WaveBlocksND.MatrixPotentialMS.calculate_jacobian">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_jacobian</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;Calculate the Jacobian matrix :math:`\nabla \lambda_i` of the potential&#39;s</span>
<span class="sd">        eigenvalues :math:`\Lambda(x)` with :math:`x \in \mathbb{R}^D`. For potentials</span>
<span class="sd">        which depend only one variable, this equals the first derivative and :math:`D=1`.</span>
<span class="sd">        Note that this function is idempotent.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_jacobian_of_matrix</span><span class="p">()</span></div>


<div class="viewcode-block" id="MatrixPotentialMS.evaluate_jacobian_at"><a class="viewcode-back" href="../../waveblocks_classes/MatrixPotentialMS.html#WaveBlocksND.MatrixPotentialMS.evaluate_jacobian_at">[docs]</a>    <span class="k">def</span> <span class="nf">evaluate_jacobian_at</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">component</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;Evaluate the list of Jacobian matrices :math:`\nabla \lambda_i(x)` at some grid</span>
<span class="sd">        nodes :math:`\Gamma` for one or all eigenvalues.</span>

<span class="sd">        :param grid: The grid nodes :math:`\Gamma` the Jacobian gets evaluated at.</span>
<span class="sd">        :type grid: A :py:class:`Grid` instance. (Numpy arrays are not directly supported yet.)</span>
<span class="sd">        :param component: The index :math:`i` of the eigenvalue :math:`\lambda_i`.</span>
<span class="sd">        :return: The value of the potential&#39;s Jacobian at the given nodes. The result</span>
<span class="sd">                 is a list of ``ndarray`` each of shape :math:`(D,1)` is we evaluate</span>
<span class="sd">                 at a single grid node or of shape :math:`(D,|\Gamma|)`</span>
<span class="sd">                 if we evaluate at multiple nodes simultaneously.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grid_wrap</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>

        <span class="n">D</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dimension</span>
        <span class="n">N</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_number_components</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">get_number_nodes</span><span class="p">(</span><span class="n">overall</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># For which eigenvalues do we need to do the computation</span>
        <span class="k">if</span> <span class="n">component</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">levels</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">levels</span> <span class="o">=</span> <span class="p">[</span><span class="n">component</span><span class="p">]</span>

        <span class="c1"># Compute eigenvectors</span>
        <span class="n">EV</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_eigenvectors_at</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="nb">sorted</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">Jn</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># For each eigenvalue</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">levels</span><span class="p">:</span>
            <span class="n">Jl</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">D</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">)</span>
            <span class="c1"># For each variable xi</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">D</span><span class="p">):</span>
                <span class="n">dAdxi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_evaluate_jacobian_of_matrix</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">grid</span><span class="p">)</span>
                <span class="c1"># TODO: Adapt to non-real eigenvectors by conjugating first EV[l]</span>
                <span class="n">Jl</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;j...,...jk,k...&quot;</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(</span><span class="n">EV</span><span class="p">[</span><span class="n">l</span><span class="p">]),</span> <span class="n">dAdxi</span><span class="p">,</span> <span class="n">EV</span><span class="p">[</span><span class="n">l</span><span class="p">])</span>

            <span class="n">Jn</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Jl</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">component</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Unpack single item</span>
            <span class="k">return</span> <span class="n">Jn</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">Jn</span><span class="p">)</span></div>


<div class="viewcode-block" id="MatrixPotentialMS.calculate_hessian"><a class="viewcode-back" href="../../waveblocks_classes/MatrixPotentialMS.html#WaveBlocksND.MatrixPotentialMS.calculate_hessian">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_hessian</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;Calculate the Hessian matrix :math:`\nabla^2 \lambda_i` of the potential&#39;s</span>
<span class="sd">        eigenvalues :math:`\Lambda(x)` with :math:`x \in \mathbb{R}^D`. For potentials</span>
<span class="sd">        which depend only one variable, this equals the second derivative and :math:`D=1`.</span>
<span class="sd">        Note that this function is idempotent.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_hessian_of_matrix</span><span class="p">()</span></div>


<div class="viewcode-block" id="MatrixPotentialMS.evaluate_hessian_at"><a class="viewcode-back" href="../../waveblocks_classes/MatrixPotentialMS.html#WaveBlocksND.MatrixPotentialMS.evaluate_hessian_at">[docs]</a>    <span class="k">def</span> <span class="nf">evaluate_hessian_at</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">component</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;Evaluate the list of Hessian matrices :math:`\nabla^2 \lambda_i(x)` at some grid</span>
<span class="sd">        nodes :math:`\Gamma` for one or all eigenvalues.</span>

<span class="sd">        :param grid: The grid nodes :math:`\Gamma` the Hessian gets evaluated at.</span>
<span class="sd">        :type grid: A :py:class:`Grid` instance. (Numpy arrays are not directly supported yet.)</span>
<span class="sd">        :param component: The index :math:`i` of the eigenvalue :math:`\lambda_i`.</span>
<span class="sd">        :return: The value of the potential&#39;s Hessian at the given nodes. The result</span>
<span class="sd">                 is an ``ndarray`` of shape :math:`(D,D)` is we evaluate at a single</span>
<span class="sd">                 grid node or of shape :math:`(D,D,|\Gamma|)` if we evaluate at multiple</span>
<span class="sd">                 nodes simultaneously.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grid_wrap</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>

        <span class="n">D</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dimension</span>
        <span class="n">N</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_number_components</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">get_number_nodes</span><span class="p">(</span><span class="n">overall</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># For which eigenvalues do we need to do the computation</span>
        <span class="k">if</span> <span class="n">component</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">levels</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">levels</span> <span class="o">=</span> <span class="p">[</span><span class="n">component</span><span class="p">]</span>

        <span class="c1"># Compute eigenvalues</span>
        <span class="n">EW</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_eigenvalues_at</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="nb">sorted</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Compute eigenvectors</span>
        <span class="n">EV</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_eigenvectors_at</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="nb">sorted</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">Hn</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># For each eigenvalue</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">levels</span><span class="p">:</span>
            <span class="n">Hl</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">D</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">)</span>

            <span class="c1"># For all variable pairs (xi, xj)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">D</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">D</span><span class="p">):</span>
                    <span class="c1"># First term</span>
                    <span class="n">dAdxidxj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_evaluate_hessian_of_matrix</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">),</span> <span class="n">grid</span><span class="p">)</span>
                    <span class="c1"># TODO: Adapt to non-real eigenvectors by conjugating first EV[l]</span>
                    <span class="n">Hl</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;j...,...jk,k...&quot;</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(</span><span class="n">EV</span><span class="p">[</span><span class="n">l</span><span class="p">]),</span> <span class="n">dAdxidxj</span><span class="p">,</span> <span class="n">EV</span><span class="p">[</span><span class="n">l</span><span class="p">])</span>

                    <span class="c1"># Second terms</span>
                    <span class="n">tmp</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">k</span> <span class="o">!=</span> <span class="n">l</span><span class="p">:</span>
                            <span class="c1"># TODO: Pull these out of the i/j loops?</span>
                            <span class="n">dAdxi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_evaluate_jacobian_of_matrix</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">grid</span><span class="p">)</span>
                            <span class="n">dAdxj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_evaluate_jacobian_of_matrix</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">grid</span><span class="p">)</span>

                            <span class="c1"># TODO: Adapt to non-real eigenvectors by conjugating first EV[l]</span>
                            <span class="n">factor1</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;j...,...jk,k...&quot;</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(</span><span class="n">EV</span><span class="p">[</span><span class="n">l</span><span class="p">]),</span> <span class="n">dAdxi</span><span class="p">,</span> <span class="n">EV</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
                            <span class="n">factor2</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;j...,...jk,k...&quot;</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(</span><span class="n">EV</span><span class="p">[</span><span class="n">l</span><span class="p">]),</span> <span class="n">dAdxj</span><span class="p">,</span> <span class="n">EV</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
                            <span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span> <span class="o">+</span> <span class="n">factor1</span> <span class="o">*</span> <span class="n">factor2</span> <span class="o">/</span> <span class="p">(</span><span class="n">EW</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">-</span> <span class="n">EW</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>

                    <span class="n">Hl</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">Hl</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">tmp</span>

            <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">Hl</span> <span class="o">=</span> <span class="n">Hl</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">D</span><span class="p">,</span> <span class="n">D</span><span class="p">))</span>
            <span class="n">Hn</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Hl</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">component</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Unpack single item</span>
            <span class="k">return</span> <span class="n">Hn</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">Hn</span><span class="p">)</span></div>


<div class="viewcode-block" id="MatrixPotentialMS.calculate_local_quadratic"><a class="viewcode-back" href="../../waveblocks_classes/MatrixPotentialMS.html#WaveBlocksND.MatrixPotentialMS.calculate_local_quadratic">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_local_quadratic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">diagonal_component</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;Calculate the local quadratic approximation matrix :math:`U(x)` of the potential&#39;s</span>
<span class="sd">        eigenvalues in :math:`\Lambda(x)`. This function can be used for the homogeneous case</span>
<span class="sd">        and takes into account the leading component :math:`\chi \in [0,\ldots,N-1]`.</span>
<span class="sd">        If the parameter :math:`i` is not given, calculate the local quadratic approximation</span>
<span class="sd">        matrix :math:`U(x)` of all the potential&#39;s eigenvalues in :math:`\Lambda`. This case</span>
<span class="sd">        can be used for the inhomogeneous case.</span>

<span class="sd">        :param diagonal_component: Dummy parameter which has no effect here.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_jacobian_of_matrix</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_hessian_of_matrix</span><span class="p">()</span></div>


<div class="viewcode-block" id="MatrixPotentialMS.evaluate_local_quadratic_at"><a class="viewcode-back" href="../../waveblocks_classes/MatrixPotentialMS.html#WaveBlocksND.MatrixPotentialMS.evaluate_local_quadratic_at">[docs]</a>    <span class="k">def</span> <span class="nf">evaluate_local_quadratic_at</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">diagonal_component</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;Numerically evaluate the local quadratic approximation matrix :math:`U(x)` of</span>
<span class="sd">        the potential&#39;s eigenvalues in :math:`\Lambda(x)` at the given grid nodes :math:`\Gamma`.</span>

<span class="sd">        :param grid: The grid :math:`\Gamma` containing the nodes :math:`\gamma` we want to</span>
<span class="sd">                     evaluate the quadratic approximation at.</span>
<span class="sd">        :type grid: A :py:class:`Grid` instance. (Numpy arrays are not directly supported yet.)</span>
<span class="sd">        :param diagonal_component: Specifies the index :math:`i` of the eigenvalue :math:`\lambda_i`</span>
<span class="sd">                                   that gets expanded into a Taylor series :math:`u_i`.</span>
<span class="sd">        :return: A list of tuples or a single tuple. Each tuple :math:`(\lambda, J, H)` contains the</span>
<span class="sd">                 the evaluated eigenvalue :math:`\lambda_i(\Gamma)`, its Jacobian :math:`J(\Gamma)`</span>
<span class="sd">                 and its Hessian :math:`H(\Gamma)` in this order.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">diagonal_component</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">V</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_eigenvalues_at</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">entry</span><span class="o">=</span><span class="p">(</span><span class="n">diagonal_component</span><span class="p">,</span> <span class="n">diagonal_component</span><span class="p">))</span>
            <span class="n">J</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_jacobian_at</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">component</span><span class="o">=</span><span class="n">diagonal_component</span><span class="p">)</span>
            <span class="n">H</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_hessian_at</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">component</span><span class="o">=</span><span class="n">diagonal_component</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">J</span><span class="p">,</span> <span class="n">H</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Vlist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_eigenvalues_at</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
            <span class="n">Jlist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_jacobian_at</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
            <span class="n">Hlist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_hessian_at</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="p">[(</span><span class="n">V</span><span class="p">,</span> <span class="n">J</span><span class="p">,</span> <span class="n">H</span><span class="p">)</span> <span class="k">for</span> <span class="n">V</span><span class="p">,</span> <span class="n">J</span><span class="p">,</span> <span class="n">H</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">Vlist</span><span class="p">,</span> <span class="n">Jlist</span><span class="p">,</span> <span class="n">Hlist</span><span class="p">)]</span>

        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">result</span><span class="p">)</span></div>


<div class="viewcode-block" id="MatrixPotentialMS.calculate_local_remainder"><a class="viewcode-back" href="../../waveblocks_classes/MatrixPotentialMS.html#WaveBlocksND.MatrixPotentialMS.calculate_local_remainder">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_local_remainder</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">diagonal_component</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;Calculate the non-quadratic remainder matrix :math:`W(x) = V(x) - U(x)` of the</span>
<span class="sd">        quadratic approximation matrix :math:`U(x)` of the potential&#39;s eigenvalue matrix</span>
<span class="sd">        :math:`\Lambda(x)`. In the homogeneous case the matrix :math:`U` is given by</span>
<span class="sd">        :math:`U(x) = \text{diag}([u_i,\ldots,u_i])` where in the inhomogeneous case it</span>
<span class="sd">        is given by :math:`U(x) = \text{diag}([u_0,\ldots,u_{N-1}])`.</span>

<span class="sd">        :param diagonal_component: Specifies the index :math:`i` of the eigenvalue :math:`\lambda_i`</span>
<span class="sd">                                   that gets expanded into a Taylor series :math:`u_i`. If set to</span>
<span class="sd">                                   ``None`` the inhomogeneous case is computed.</span>
<span class="sd">        :type diagonal_component: Integer or ``None`` (default)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_jacobian_of_matrix</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_hessian_of_matrix</span><span class="p">()</span></div>


<div class="viewcode-block" id="MatrixPotentialMS.evaluate_local_remainder_at"><a class="viewcode-back" href="../../waveblocks_classes/MatrixPotentialMS.html#WaveBlocksND.MatrixPotentialMS.evaluate_local_remainder_at">[docs]</a>    <span class="k">def</span> <span class="nf">evaluate_local_remainder_at</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">diagonal_component</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">entry</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;Numerically evaluate the non-quadratic remainder :math:`W(x)` of the quadratic</span>
<span class="sd">        approximation :math:`U(x)` of the potential&#39;s eigenvalue :math:`\Lambda(x)` at the</span>
<span class="sd">        given nodes :math:`\Gamma`.</span>

<span class="sd">         Warning: do not set the ``diagonal_component`` and the ``entry`` parameter both to ``None``.</span>

<span class="sd">        :param grid: The grid nodes :math:`\Gamma` the remainder :math:`W` gets evaluated at.</span>
<span class="sd">        :param position: The point :math:`q \in \mathbb{R}^D` where the Taylor series is computed.</span>
<span class="sd">        :param diagonal_component: Specifies the index :math:`i` of the eigenvalue :math:`\lambda_i`</span>
<span class="sd">                                   that gets expanded into a Taylor series :math:`u_i` and whose</span>
<span class="sd">                                   remainder matrix :math:`W(x) = V(x) - \text{diag}([u_i,\ldots,u_i])`</span>
<span class="sd">                                   we evaluate. If set to ``None`` the inhomogeneous case given by</span>
<span class="sd">                                   :math:`W(x) = V(x) - \text{diag}([u_0,\ldots,u_{N-1}])` is computed.</span>
<span class="sd">        :type diagonal_component: Integer or ``None`` (default)</span>
<span class="sd">        :param entry: The entry :math:`\left(i,j\right)` of the remainder matrix :math:`W`</span>
<span class="sd">                      that is evaluated.</span>
<span class="sd">        :type entry: A python tuple of two integers.</span>
<span class="sd">        :return: A list with :math:`N^2` ``ndarray`` elements or a single ``ndarray``. Each</span>
<span class="sd">                 containing the values of :math:`W_{i,j}(\Gamma)`. Each array is of shape</span>
<span class="sd">                 :math:`(1,|\Gamma|)`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grid_wrap</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
        <span class="n">position</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">position</span><span class="p">)</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">get_nodes</span><span class="p">()</span>
        <span class="n">N</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_number_components</span>

        <span class="k">if</span> <span class="n">entry</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">rows</span> <span class="o">=</span> <span class="p">[</span><span class="n">entry</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">entry</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rows</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
            <span class="n">cols</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>

        <span class="n">W</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="n">diagonal_component</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Homogeneous case</span>
            <span class="n">V</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_at</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
            <span class="n">L</span><span class="p">,</span> <span class="n">J</span><span class="p">,</span> <span class="n">H</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_local_quadratic_at</span><span class="p">(</span><span class="n">position</span><span class="p">,</span> <span class="n">diagonal_component</span><span class="o">=</span><span class="n">diagonal_component</span><span class="p">)</span>

            <span class="c1"># Compute quadratic approximation</span>
            <span class="c1"># L(q) + J(q)*(G-q) + 1/2*(G-q)T*H(q)*(G-q)</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">nodes</span> <span class="o">-</span> <span class="n">position</span>
            <span class="n">U</span> <span class="o">=</span> <span class="n">L</span> <span class="o">+</span> <span class="n">numpy</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;i...,i...&quot;</span><span class="p">,</span> <span class="n">J</span><span class="p">,</span> <span class="n">df</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;j...,jk...,k...&quot;</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">df</span><span class="p">)</span>

            <span class="c1"># Compute the remainder W = V - U</span>
            <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">rows</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">cols</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">row</span> <span class="o">==</span> <span class="n">col</span><span class="p">:</span>
                        <span class="n">W</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">V</span><span class="p">[</span><span class="n">row</span> <span class="o">*</span> <span class="n">N</span> <span class="o">+</span> <span class="n">col</span><span class="p">]</span> <span class="o">-</span> <span class="n">U</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">W</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">V</span><span class="p">[</span><span class="n">row</span> <span class="o">*</span> <span class="n">N</span> <span class="o">+</span> <span class="n">col</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Inhomogeneous case</span>
            <span class="n">V</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_at</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
            <span class="c1"># Compute the remainder W = V - U</span>
            <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">rows</span><span class="p">:</span>
                <span class="n">L</span><span class="p">,</span> <span class="n">J</span><span class="p">,</span> <span class="n">H</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_local_quadratic_at</span><span class="p">(</span><span class="n">position</span><span class="p">,</span> <span class="n">diagonal_component</span><span class="o">=</span><span class="n">row</span><span class="p">)</span>
                <span class="c1"># Compute quadratic approximation</span>
                <span class="c1"># L(q) + J(q)*(G-q) + 1/2*(G-q)T*H(q)*(G-q)</span>
                <span class="n">df</span> <span class="o">=</span> <span class="n">nodes</span> <span class="o">-</span> <span class="n">position</span>
                <span class="n">U</span> <span class="o">=</span> <span class="n">L</span> <span class="o">+</span> <span class="n">numpy</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;i...,i...&quot;</span><span class="p">,</span> <span class="n">J</span><span class="p">,</span> <span class="n">df</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;j...,jk...,k...&quot;</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">df</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">cols</span><span class="p">:</span>

                    <span class="k">if</span> <span class="n">row</span> <span class="o">==</span> <span class="n">col</span><span class="p">:</span>
                        <span class="n">W</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">V</span><span class="p">[</span><span class="n">row</span> <span class="o">*</span> <span class="n">N</span> <span class="o">+</span> <span class="n">col</span><span class="p">]</span> <span class="o">-</span> <span class="n">U</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">W</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">V</span><span class="p">[</span><span class="n">row</span> <span class="o">*</span> <span class="n">N</span> <span class="o">+</span> <span class="n">col</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">entry</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Unpack single item</span>
            <span class="k">return</span> <span class="n">W</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">W</span><span class="p">)</span></div></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">WaveBlocksND devel documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2016, R. Bourquin.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.4.5.
    </div>
  </body>
</html>