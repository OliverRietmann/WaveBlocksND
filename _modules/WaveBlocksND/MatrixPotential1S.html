<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>WaveBlocksND.MatrixPotential1S &mdash; WaveBlocksND devel documentation</title>
    
    <link rel="stylesheet" href="../../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     'devel',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="top" title="WaveBlocksND devel documentation" href="../../index.html" />
    <link rel="up" title="Module code" href="../index.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">WaveBlocksND devel documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for WaveBlocksND.MatrixPotential1S</h1><div class="highlight"><pre>
<span></span><span class="sd">r&quot;&quot;&quot;The WaveBlocks Project</span>

<span class="sd">This file contains code for the representation of potentials :math:`V(x)`</span>
<span class="sd">that contain only a single energy level :math:`\lambda_0`. The number</span>
<span class="sd">of space dimensions can be arbitrary, :math:`x \in \mathbb{R}^D`.</span>

<span class="sd">@author: R. Bourquin</span>
<span class="sd">@copyright: Copyright (C) 2010, 2011, 2012, 2014 R. Bourquin</span>
<span class="sd">@license: Modified BSD License</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">sympy</span>
<span class="kn">import</span> <span class="nn">numpy</span>

<span class="kn">from</span> <span class="nn">WaveBlocksND.MatrixPotential</span> <span class="k">import</span> <span class="n">MatrixPotential</span>
<span class="kn">from</span> <span class="nn">WaveBlocksND.AbstractGrid</span> <span class="k">import</span> <span class="n">AbstractGrid</span>
<span class="kn">from</span> <span class="nn">WaveBlocksND.GridWrapper</span> <span class="k">import</span> <span class="n">GridWrapper</span>
<span class="kn">from</span> <span class="nn">WaveBlocksND</span> <span class="k">import</span> <span class="n">GlobalDefaults</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;MatrixPotential1S&quot;</span><span class="p">]</span>


<div class="viewcode-block" id="MatrixPotential1S"><a class="viewcode-back" href="../../waveblocks_classes/MatrixPotential1S.html#WaveBlocksND.MatrixPotential1S">[docs]</a><span class="k">class</span> <span class="nc">MatrixPotential1S</span><span class="p">(</span><span class="n">MatrixPotential</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;This class represents a scalar potential :math:`V(x)`. The potential is</span>
<span class="sd">    given as an analytic :math:`1 \times 1` matrix expression. Some symbolic</span>
<span class="sd">    calculations with the potential are supported.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expression</span><span class="p">,</span> <span class="n">variables</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;Create a new :py:class:`MatrixPotential1S` instance for a given</span>
<span class="sd">        potential matrix :math:`V(x)`.</span>

<span class="sd">        :param expression: The mathematical expression representing the potential.</span>
<span class="sd">        :type expressiom: A `Sympy` matrix type.</span>
<span class="sd">        :param variables: The variables corresponding to the space dimensions.</span>
<span class="sd">        :type variables: A list of `Sympy` symbols.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># This class handles potentials with a single energy level.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_number_components</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="c1"># The variables that represents position space. The order matters!</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span> <span class="o">=</span> <span class="n">variables</span>

        <span class="c1"># The dimension of position space.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dimension</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">variables</span><span class="p">)</span>

        <span class="c1"># Try symbolic simplification</span>
        <span class="k">if</span> <span class="s2">&quot;try_simplification&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_try_simplify</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;try_simplification&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_try_simplify</span> <span class="o">=</span> <span class="n">GlobalDefaults</span><span class="o">.</span><span class="n">__dict__</span><span class="p">[</span><span class="s2">&quot;try_simplification&quot;</span><span class="p">]</span>

        <span class="c1"># The the potential, symbolic expressions and evaluatable functions</span>
        <span class="k">assert</span> <span class="n">expression</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_potential_s</span> <span class="o">=</span> <span class="n">expression</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_potential_n</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">lambdify</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_potential_s</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="s2">&quot;numpy&quot;</span><span class="p">)</span>

        <span class="c1"># The cached eigenvalues, symbolic expressions and evaluatable functions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_eigenvalues_s</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_eigenvalues_n</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># The cached eigenvectors, symbolic expressions and evaluatable functions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_eigenvectors_s</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_eigenvectors_n</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># The cached exponential, symbolic expressions and evaluatable functions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_exponential_s</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_exponential_n</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># The cached Jacobian of the eigenvalues, symbolic expressions and evaluatable functions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_jacobian_can_s</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_jacobian_can_n</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_jacobian_eigen_s</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_jacobian_eigen_n</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># The cached Hessian of the eigenvalues, symbolic expressions and evaluatable functions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hessian_s</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hessian_n</span> <span class="o">=</span> <span class="kc">None</span>


    <span class="k">def</span> <span class="nf">_grid_wrap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">agrid</span><span class="p">):</span>
        <span class="c1"># TODO: Consider additional input types for &quot;nodes&quot;:</span>
        <span class="c1">#       list of numpy ndarrays, list of single python scalars</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">agrid</span><span class="p">,</span> <span class="n">AbstractGrid</span><span class="p">):</span>
            <span class="n">agrid</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">agrid</span><span class="p">)</span>
            <span class="n">agrid</span> <span class="o">=</span> <span class="n">agrid</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dimension</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">agrid</span> <span class="o">=</span> <span class="n">GridWrapper</span><span class="p">(</span><span class="n">agrid</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">agrid</span>


<div class="viewcode-block" id="MatrixPotential1S.evaluate_at"><a class="viewcode-back" href="../../waveblocks_classes/MatrixPotential1S.html#WaveBlocksND.MatrixPotential1S.evaluate_at">[docs]</a>    <span class="k">def</span> <span class="nf">evaluate_at</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">entry</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">as_matrix</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;Evaluate the potential :math:`V(x)` elementwise on a grid :math:`\Gamma`.</span>

<span class="sd">        :param grid: The grid containing the nodes :math:`\gamma_i` we want</span>
<span class="sd">                     to evaluate the potential at.</span>
<span class="sd">        :type grid: A :py:class:`Grid` instance. (Numpy arrays are not directly supported yet.)</span>
<span class="sd">        :param entry: The indices :math:`(i,j)` of the component :math:`V_{i,j}(x)`</span>
<span class="sd">                      we want to evaluate or ``None`` to evaluate all entries.</span>
<span class="sd">                      This has no effect here as we only have a single entry :math:`V_{0,0}`.</span>
<span class="sd">        :type entry: A python tuple of two integers.</span>
<span class="sd">        :param as_matrix: Dummy parameter which has no effect here.</span>
<span class="sd">        :return: A list containing a single numpy ``ndarray`` of shape :math:`(1,|\Gamma|)`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grid_wrap</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>

        <span class="c1"># Evaluate the potential at the given nodes</span>
        <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_potential_n</span><span class="p">(</span><span class="o">*</span><span class="n">grid</span><span class="o">.</span><span class="n">get_nodes</span><span class="p">(</span><span class="n">split</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>

        <span class="c1"># Test for potential being constant</span>
        <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">values</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="p">,):</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">values</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">get_number_nodes</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">)</span>

        <span class="c1"># Put the result in correct shape (1, #gridnodes)</span>
        <span class="n">N</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">get_number_nodes</span><span class="p">(</span><span class="n">overall</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">values</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">))]</span>

        <span class="c1"># TODO: Consider unpacking single ndarray iff entry != None</span>
        <span class="k">if</span> <span class="n">entry</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="MatrixPotential1S.calculate_eigenvalues"><a class="viewcode-back" href="../../waveblocks_classes/MatrixPotential1S.html#WaveBlocksND.MatrixPotential1S.calculate_eigenvalues">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_eigenvalues</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;Calculate the eigenvalue :math:`\lambda_0(x)` of the potential :math:`V(x)`.</span>
<span class="sd">        In the scalar case this is just equal to the matrix entry :math:`V_{0,0}(x)`.</span>
<span class="sd">        Note: This function is idempotent and the eigenvalues are memoized for later reuse.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eigenvalues_s</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_eigenvalues_s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_potential_s</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_eigenvalues_n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_potential_n</span></div>


<div class="viewcode-block" id="MatrixPotential1S.evaluate_eigenvalues_at"><a class="viewcode-back" href="../../waveblocks_classes/MatrixPotential1S.html#WaveBlocksND.MatrixPotential1S.evaluate_eigenvalues_at">[docs]</a>    <span class="k">def</span> <span class="nf">evaluate_eigenvalues_at</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">entry</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">as_matrix</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;Evaluate the eigenvalue :math:`\lambda_0(x)` elementwise on a grid :math:`\Gamma`.</span>

<span class="sd">        :param grid: The grid containing the nodes :math:`\gamma_i` we want</span>
<span class="sd">                     to evaluate the eigenvalue at.</span>
<span class="sd">        :type grid: A :py:class:`Grid` instance. (Numpy arrays are not directly supported yet.)</span>
<span class="sd">        :param entry: The indices :math:`(i,j)` of the component :math:`\Lambda_{i,j}(x)`</span>
<span class="sd">                      we want to evaluate or ``None`` to evaluate all entries. If :math:`j = i`</span>
<span class="sd">                      then we evaluate the eigenvalue :math:`\lambda_i(x)`. This has no</span>
<span class="sd">                      effect here as we only have a single entry :math:`\lambda_0`.</span>
<span class="sd">        :type entry: A python tuple of two integers.</span>
<span class="sd">        :param as_matrix: Dummy parameter which has no effect here.</span>
<span class="sd">        :return: A list containing a single numpy ndarray of shape :math:`(N_1, ... ,N_D)`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Just evaluate the potential</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_at</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">entry</span><span class="o">=</span><span class="n">entry</span><span class="p">,</span> <span class="n">as_matrix</span><span class="o">=</span><span class="n">as_matrix</span><span class="p">)</span></div>


<div class="viewcode-block" id="MatrixPotential1S.calculate_eigenvectors"><a class="viewcode-back" href="../../waveblocks_classes/MatrixPotential1S.html#WaveBlocksND.MatrixPotential1S.calculate_eigenvectors">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_eigenvectors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;Calculate the eigenvector :math:`\nu_0(x)` of the potential :math:`V(x)`.</span>
<span class="sd">        In the scalar case this is just the value :math:`1`.</span>
<span class="sd">        Note: This function is idempotent and the eigenvectors are memoized for later reuse.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># We will never use the values</span>
        <span class="k">pass</span></div>


<div class="viewcode-block" id="MatrixPotential1S.evaluate_eigenvectors_at"><a class="viewcode-back" href="../../waveblocks_classes/MatrixPotential1S.html#WaveBlocksND.MatrixPotential1S.evaluate_eigenvectors_at">[docs]</a>    <span class="k">def</span> <span class="nf">evaluate_eigenvectors_at</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">entry</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;Evaluate the eigenvector :math:`\nu_0(x)` elementwise on a grid :math:`\Gamma`.</span>

<span class="sd">        :param grid: The grid containing the nodes :math:`\gamma_i` we want</span>
<span class="sd">                     to evaluate the eigenvector at.</span>
<span class="sd">        :type grid: A :py:class:`Grid` instance. (Numpy arrays are not directly supported yet.)</span>
<span class="sd">        :param entry: The index :math:`i` of the eigenvector :math:`\nu_i(x)`</span>
<span class="sd">                      we want to evaluate or ``None`` to evaluate all eigenvectors.</span>
<span class="sd">                      This has no effect here as we only have a single entry :math:`\nu_0`.</span>
<span class="sd">        :type entry: A singly python  integer.</span>
<span class="sd">        :return: A list containing the numpy ndarrays, all of shape :math:`(1, |\Gamma|)`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: Rethink about the &#39;entry&#39; parameter here. Do we need it?</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grid_wrap</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">grid</span><span class="o">.</span><span class="n">get_number_nodes</span><span class="p">(</span><span class="n">overall</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">)])</span></div>


<div class="viewcode-block" id="MatrixPotential1S.calculate_exponential"><a class="viewcode-back" href="../../waveblocks_classes/MatrixPotential1S.html#WaveBlocksND.MatrixPotential1S.calculate_exponential">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_exponential</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">factor</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;Calculate the matrix exponential :math:`\exp(\alpha V)`. In the</span>
<span class="sd">        case of this class the matrix is of size :math:`1 \times 1` thus</span>
<span class="sd">        the exponential simplifies to the scalar exponential function.</span>
<span class="sd">        Note: This function is idempotent.</span>

<span class="sd">        :param factor: The prefactor :math:`\alpha` in the exponential.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_exponential_s</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">factor</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_potential_s</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_exponential_n</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">lambdify</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_exponential_s</span><span class="p">,</span> <span class="s2">&quot;numpy&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="MatrixPotential1S.evaluate_exponential_at"><a class="viewcode-back" href="../../waveblocks_classes/MatrixPotential1S.html#WaveBlocksND.MatrixPotential1S.evaluate_exponential_at">[docs]</a>    <span class="k">def</span> <span class="nf">evaluate_exponential_at</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">entry</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;Evaluate the exponential of the potential matrix :math:`V(x)` on a grid :math:`\Gamma`.</span>

<span class="sd">        :param grid: The grid containing the nodes :math:`\gamma_i` we want</span>
<span class="sd">                     to evaluate the exponential at.</span>
<span class="sd">        :type grid: A :py:class:`Grid` instance. (Numpy arrays are not directly supported yet.)</span>
<span class="sd">        :return: The numerical approximation of the matrix exponential at the given grid nodes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grid_wrap</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_exponential_n</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">calculate_exponential</span><span class="p">()</span>

        <span class="c1"># Evaluate the exponential at the given nodes</span>
        <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_exponential_n</span><span class="p">(</span><span class="o">*</span><span class="n">grid</span><span class="o">.</span><span class="n">get_nodes</span><span class="p">(</span><span class="n">split</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>

        <span class="c1"># Test for potential being constant</span>
        <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">values</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="p">,):</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">values</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">get_number_nodes</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">)</span>

        <span class="c1"># Put the result in correct shape (1, #gridnodes)</span>
        <span class="n">N</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">get_number_nodes</span><span class="p">(</span><span class="n">overall</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">values</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">))]</span>

        <span class="c1"># TODO: Consider unpacking single ndarray iff entry != None</span>
        <span class="k">if</span> <span class="n">entry</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="MatrixPotential1S.calculate_jacobian"><a class="viewcode-back" href="../../waveblocks_classes/MatrixPotential1S.html#WaveBlocksND.MatrixPotential1S.calculate_jacobian">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_jacobian</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;Calculate the Jacobian matrix :math:`\nabla V` of the potential :math:`V(x)`</span>
<span class="sd">        with :math:`x \in \mathbb{R}^D`. For potentials which depend only one variable,</span>
<span class="sd">        this equals the first derivative and :math:`D=1`. Note that this function is idempotent.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_jacobian_eigen_s</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># TODO: Add symbolic simplification</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_jacobian_eigen_s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_potential_s</span><span class="o">.</span><span class="n">jacobian</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_jacobian_eigen_n</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">sympy</span><span class="o">.</span><span class="n">lambdify</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="s2">&quot;numpy&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_jacobian_eigen_s</span><span class="p">)</span></div>


<div class="viewcode-block" id="MatrixPotential1S.evaluate_jacobian_at"><a class="viewcode-back" href="../../waveblocks_classes/MatrixPotential1S.html#WaveBlocksND.MatrixPotential1S.evaluate_jacobian_at">[docs]</a>    <span class="k">def</span> <span class="nf">evaluate_jacobian_at</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">component</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;Evaluate the potential&#39;s Jacobian :math:`\nabla \Lambda(x)` at some grid</span>
<span class="sd">        nodes :math:`\Gamma`.</span>

<span class="sd">        :param grid: The grid nodes :math:`\Gamma` the Jacobian gets evaluated at.</span>
<span class="sd">        :param component: Dummy parameter that has no effect here.</span>
<span class="sd">        :return: The value of the potential&#39;s Jacobian at the given nodes. The result</span>
<span class="sd">                 is an ``ndarray`` of shape :math:`(D,1)` is we evaluate at a single</span>
<span class="sd">                 grid node or of shape :math:`(D,|\Gamma|)`</span>
<span class="sd">                 if we evaluate at multiple nodes simultaneously.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: Rethink about the &#39;component&#39; parameter here. Do we need it?</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grid_wrap</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">get_nodes</span><span class="p">(</span><span class="n">split</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">D</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dimension</span>
        <span class="n">N</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">get_number_nodes</span><span class="p">(</span><span class="n">overall</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">J</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">D</span><span class="p">,</span> <span class="n">N</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">D</span><span class="p">):</span>
            <span class="n">J</span><span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_jacobian_can_n</span><span class="p">[</span><span class="n">row</span><span class="p">](</span><span class="o">*</span><span class="n">nodes</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">J</span></div>


<div class="viewcode-block" id="MatrixPotential1S.calculate_jacobian_canonical"><a class="viewcode-back" href="../../waveblocks_classes/MatrixPotential1S.html#WaveBlocksND.MatrixPotential1S.calculate_jacobian_canonical">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_jacobian_canonical</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;Calculate the Jacobian matrix :math:`\nabla V(x)` of the potential :math:`V(x)`</span>
<span class="sd">        with :math:`x \in \mathbb{R}^D`. For potentials which depend only one variable,</span>
<span class="sd">        this equals the first derivative and :math:`D=1`. Note that this function is idempotent.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_jacobian_can_s</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># TODO: Add symbolic simplification</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_jacobian_can_s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_potential_s</span><span class="o">.</span><span class="n">jacobian</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_jacobian_can_n</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">sympy</span><span class="o">.</span><span class="n">lambdify</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="s2">&quot;numpy&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_jacobian_can_s</span><span class="p">])</span></div>


<div class="viewcode-block" id="MatrixPotential1S.evaluate_jacobian_canonical_at"><a class="viewcode-back" href="../../waveblocks_classes/MatrixPotential1S.html#WaveBlocksND.MatrixPotential1S.evaluate_jacobian_canonical_at">[docs]</a>    <span class="k">def</span> <span class="nf">evaluate_jacobian_canonical_at</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">component</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;Evaluate the potential&#39;s Jacobian :math:`\nabla V(x)` at some grid</span>
<span class="sd">        nodes :math:`\Gamma`.</span>

<span class="sd">        :param grid: The grid nodes :math:`\Gamma` the Jacobian gets evaluated at.</span>
<span class="sd">        :param component: Dummy parameter that has no effect here.</span>
<span class="sd">        :return: The value of the potential&#39;s Jacobian at the given nodes. The result</span>
<span class="sd">                 is an ``ndarray`` of shape :math:`(D,1)` is we evaluate at a single</span>
<span class="sd">                 grid node or of shape :math:`(D,|\Gamma|)`</span>
<span class="sd">                 if we evaluate at multiple nodes simultaneously.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: Rethink about the &#39;component&#39; parameter here. Do we need it?</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grid_wrap</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">get_nodes</span><span class="p">(</span><span class="n">split</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">D</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dimension</span>
        <span class="n">N</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">get_number_nodes</span><span class="p">(</span><span class="n">overall</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">J</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">D</span><span class="p">,</span> <span class="n">N</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">D</span><span class="p">):</span>
            <span class="n">J</span><span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_jacobian_eigen_n</span><span class="p">[</span><span class="n">row</span><span class="p">](</span><span class="o">*</span><span class="n">nodes</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">J</span></div>


<div class="viewcode-block" id="MatrixPotential1S.calculate_hessian"><a class="viewcode-back" href="../../waveblocks_classes/MatrixPotential1S.html#WaveBlocksND.MatrixPotential1S.calculate_hessian">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_hessian</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;Calculate the Hessian matrix :math:`\nabla^2 V` of the potential :math:`V(x)`</span>
<span class="sd">        with :math:`x \in \mathbb{R}^D`. For potentials which depend only one variable,</span>
<span class="sd">        this equals the second derivative and :math:`D=1`. Note that this function is idempotent.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hessian_s</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># TODO: Add symbolic simplification</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_hessian_s</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">hessian</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_potential_s</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_hessian_n</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">sympy</span><span class="o">.</span><span class="n">lambdify</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="s2">&quot;numpy&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hessian_s</span><span class="p">)</span></div>


<div class="viewcode-block" id="MatrixPotential1S.evaluate_hessian_at"><a class="viewcode-back" href="../../waveblocks_classes/MatrixPotential1S.html#WaveBlocksND.MatrixPotential1S.evaluate_hessian_at">[docs]</a>    <span class="k">def</span> <span class="nf">evaluate_hessian_at</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">component</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;Evaluate the potential&#39;s Hessian :math:`\nabla^2 V(x)` at some grid</span>
<span class="sd">        nodes :math:`\Gamma`.</span>

<span class="sd">        :param grid: The grid nodes :math:`\Gamma` the Hessian gets evaluated at.</span>
<span class="sd">        :param component: Dummy parameter that has no effect here.</span>
<span class="sd">        :return: The value of the potential&#39;s Hessian at the given nodes. The result</span>
<span class="sd">                 is an ``ndarray`` of shape :math:`(D,D)` is we evaluate at a single</span>
<span class="sd">                 grid node or of shape :math:`(|\Gamma|,D,D)` if we evaluate at multiple</span>
<span class="sd">                 nodes simultaneously.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: Rethink about the &#39;component&#39; parameter here. Do we need it?</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grid_wrap</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">get_nodes</span><span class="p">(</span><span class="n">split</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">D</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dimension</span>
        <span class="n">N</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">get_number_nodes</span><span class="p">(</span><span class="n">overall</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">H</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">D</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">D</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">D</span><span class="p">):</span>
                <span class="n">H</span><span class="p">[:,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hessian_n</span><span class="p">[</span><span class="n">row</span> <span class="o">*</span> <span class="n">D</span> <span class="o">+</span> <span class="n">col</span><span class="p">](</span><span class="o">*</span><span class="n">nodes</span><span class="p">)</span>

        <span class="c1"># &#39;squeeze&#39; would be dangerous here, make sure it works in the 1D case too</span>
        <span class="k">if</span> <span class="n">N</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">H</span> <span class="o">=</span> <span class="n">H</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>

        <span class="k">return</span> <span class="n">H</span></div>


<div class="viewcode-block" id="MatrixPotential1S.calculate_local_quadratic"><a class="viewcode-back" href="../../waveblocks_classes/MatrixPotential1S.html#WaveBlocksND.MatrixPotential1S.calculate_local_quadratic">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_local_quadratic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">diagonal_component</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;Calculate the local quadratic approximation :math:`U(x)` of the potential&#39;s</span>
<span class="sd">        eigenvalue :math:`\lambda(x)`. Note that this function is idempotent.</span>

<span class="sd">        :param diagonal_component: Dummy parameter that has no effect here.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Calculation already done at some earlier time?</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calculate_eigenvalues</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calculate_jacobian</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calculate_hessian</span><span class="p">()</span>

        <span class="c1"># Construct function to evaluate the Taylor approximation at point q at the given nodes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_taylor_eigen_s</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eigenvalues_s</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_jacobian_eigen_s</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hessian_s</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_taylor_eigen_n</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eigenvalues_n</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_jacobian_eigen_n</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hessian_n</span><span class="p">)]</span></div>


<div class="viewcode-block" id="MatrixPotential1S.evaluate_local_quadratic_at"><a class="viewcode-back" href="../../waveblocks_classes/MatrixPotential1S.html#WaveBlocksND.MatrixPotential1S.evaluate_local_quadratic_at">[docs]</a>    <span class="k">def</span> <span class="nf">evaluate_local_quadratic_at</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">diagonal_component</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;Numerically evaluate the local quadratic approximation :math:`U(x)` of</span>
<span class="sd">        the potential&#39;s eigenvalue :math:`\lambda(x)` at the given grid nodes :math:`\Gamma`.</span>
<span class="sd">        This function is used for the homogeneous case.</span>

<span class="sd">        :param grid: The grid nodes :math:`\Gamma` the quadratic approximation gets evaluated at.</span>
<span class="sd">        :param diagonal_component: Dummy parameter that has no effect here.</span>
<span class="sd">        :return: A list containing the values :math:`V(\Gamma)`, :math:`\nabla V(\Gamma)` and</span>
<span class="sd">                 :math:`\nabla^2 V(\Gamma)`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grid_wrap</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>

        <span class="c1"># TODO: Relate this to the _taylor_eigen_{s,n} data</span>
        <span class="n">V</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_eigenvalues_at</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">entry</span><span class="o">=</span><span class="p">(</span><span class="n">diagonal_component</span><span class="p">,</span> <span class="n">diagonal_component</span><span class="p">))</span>
        <span class="n">J</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_jacobian_eigen_at</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
        <span class="n">H</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_hessian_at</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">V</span><span class="p">,</span> <span class="n">J</span><span class="p">,</span> <span class="n">H</span><span class="p">])</span></div>


<div class="viewcode-block" id="MatrixPotential1S.calculate_local_remainder"><a class="viewcode-back" href="../../waveblocks_classes/MatrixPotential1S.html#WaveBlocksND.MatrixPotential1S.calculate_local_remainder">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_local_remainder</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">diagonal_component</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;Calculate the non-quadratic remainder :math:`W(x) = V(x) - U(x)` of the quadratic</span>
<span class="sd">        Taylor approximation :math:`U(x)` of the potential&#39;s eigenvalue :math:`\lambda(x)`.</span>
<span class="sd">        Note that this function is idempotent.</span>

<span class="sd">        :param diagonal_component: Dummy parameter that has no effect here.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Calculation already done at some earlier time?</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calculate_eigenvalues</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calculate_jacobian</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calculate_hessian</span><span class="p">()</span>

        <span class="c1"># Point q where the Taylor series is computed</span>
        <span class="c1"># This is a column vector q = (q1, ... ,qD)</span>
        <span class="n">qs</span> <span class="o">=</span> <span class="p">[</span><span class="n">sympy</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="s2">&quot;q&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="p">)]</span>

        <span class="n">pairs</span> <span class="o">=</span> <span class="p">[(</span><span class="n">xi</span><span class="p">,</span> <span class="n">qi</span><span class="p">)</span> <span class="k">for</span> <span class="n">xi</span><span class="p">,</span> <span class="n">qi</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="p">,</span> <span class="n">qs</span><span class="p">)]</span>

        <span class="n">V</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eigenvalues_s</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">pairs</span><span class="p">)</span>
        <span class="n">J</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_jacobian_eigen_s</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">pairs</span><span class="p">)</span>
        <span class="n">H</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hessian_s</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">pairs</span><span class="p">)</span>

        <span class="c1"># Symbolic expression for the quadratic Taylor expansion term</span>
        <span class="n">xmq</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Matrix</span><span class="p">([(</span><span class="n">xi</span> <span class="o">-</span> <span class="n">qi</span><span class="p">)</span> <span class="k">for</span> <span class="n">xi</span><span class="p">,</span> <span class="n">qi</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="p">,</span> <span class="n">qs</span><span class="p">)])</span>
        <span class="n">quadratic</span> <span class="o">=</span> <span class="n">V</span> <span class="o">+</span> <span class="n">J</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">xmq</span> <span class="o">+</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">xmq</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">H</span> <span class="o">*</span> <span class="n">xmq</span>

        <span class="c1"># Symbolic simplification may fail</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_try_simplify</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">quadratic</span> <span class="o">=</span> <span class="n">quadratic</span><span class="o">.</span><span class="n">applyfunc</span><span class="p">(</span><span class="n">sympy</span><span class="o">.</span><span class="n">simplify</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">pass</span>

        <span class="c1"># Symbolic expression for the Taylor expansion remainder term</span>
        <span class="n">remainder</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_potential_s</span> <span class="o">-</span> <span class="n">quadratic</span>

        <span class="c1"># Symbolic simplification may fail</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_try_simplify</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">remainder</span> <span class="o">=</span> <span class="n">remainder</span><span class="o">.</span><span class="n">applyfunc</span><span class="p">(</span><span class="n">sympy</span><span class="o">.</span><span class="n">simplify</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">pass</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_remainder_s</span> <span class="o">=</span> <span class="n">remainder</span>

        <span class="c1"># Construct functions to evaluate the approximation at point q at the given nodes</span>
        <span class="c1"># The variable ordering in lambdify is [x1, ..., xD, q1, ...., qD]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_remainder_n</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">sympy</span><span class="o">.</span><span class="n">lambdify</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="p">)</span> <span class="o">+</span> <span class="n">qs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_remainder_s</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="s2">&quot;numpy&quot;</span><span class="p">)])</span></div>


<div class="viewcode-block" id="MatrixPotential1S.evaluate_local_remainder_at"><a class="viewcode-back" href="../../waveblocks_classes/MatrixPotential1S.html#WaveBlocksND.MatrixPotential1S.evaluate_local_remainder_at">[docs]</a>    <span class="k">def</span> <span class="nf">evaluate_local_remainder_at</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">diagonal_component</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">entry</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;Numerically evaluate the non-quadratic remainder :math:`W(x)` of the quadratic</span>
<span class="sd">        approximation :math:`U(x)` of the potential&#39;s eigenvalue :math:`\lambda(x)` at the</span>
<span class="sd">        given nodes :math:`\Gamma`.</span>

<span class="sd">        :param grid: The grid nodes :math:`\Gamma` the remainder :math:`W` gets evaluated at.</span>
<span class="sd">        :param position: The point :math:`q \in \mathbb{R}^D` where the Taylor series is computed.</span>
<span class="sd">        :param diagonal_component: Dummy parameter that has no effect here.</span>
<span class="sd">        :keyword entry: Dummy parameter that has no effect here.</span>
<span class="sd">        :return: A list with a single entry consisting of an ``ndarray`` containing the</span>
<span class="sd">                 values of :math:`W(\Gamma)`. The array is of shape :math:`(1,|\Gamma|)`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grid_wrap</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
        <span class="n">position</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">position</span><span class="p">)</span>

        <span class="c1"># Evaluate the remainder at the given nodes</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">get_nodes</span><span class="p">(</span><span class="n">split</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">+</span> <span class="n">numpy</span><span class="o">.</span><span class="n">vsplit</span><span class="p">(</span><span class="n">position</span><span class="p">,</span> <span class="n">position</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_remainder_n</span><span class="p">[</span><span class="mi">0</span><span class="p">](</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

        <span class="c1"># Test for potential being constant</span>
        <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">values</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="p">,):</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">values</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">get_number_nodes</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">)</span>

        <span class="c1"># Put the result in correct shape (1, #gridnodes)</span>
        <span class="n">N</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">get_number_nodes</span><span class="p">(</span><span class="n">overall</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">values</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">))]</span>

        <span class="c1"># TODO: Consider unpacking single ndarray iff entry != None</span>
        <span class="k">if</span> <span class="n">entry</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">result</span></div></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">WaveBlocksND devel documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2016, R. Bourquin.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.4.5.
    </div>
  </body>
</html>